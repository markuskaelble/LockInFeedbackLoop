import time
import warnings
import numpy as np
import zhinst.utils



def setup_scope(
    device_id,
    do_plot=False,
    scope_inputselect=0,
    sigouts_amplitude=0.1,
    sigouts_range=1.0,
    module_averaging_weight=1,
    module_historylength=20,
    min_num_records=1,
):


    apilevel_example = 1
    # Call a zhinst utility function that returns:
    # - an API session `daq` in order to communicate with devices via the data server.
    # - the device ID string that specifies the device branch in the server's node hierarchy.
    # - the device's discovery properties.
    err_msg = "This example only supports HF2 Instruments."
    (daq, device, props) = zhinst.utils.create_api_session(
        device_id, apilevel_example, required_devtype="HF2", required_err_msg=err_msg
    )
    zhinst.utils.api_server_version_check(daq)

    # Enable the API's log.
    daq.setDebugLevel(3)

    # Create a base configuration: Disable all available outputs, awgs, demods, scopes,...
    zhinst.utils.disable_everything(daq, device)

    # Now configure the instrument for this experiment.

    # Determine the sigin/sigout channels to configure based on the specified scope inputselect.
    if scope_inputselect in [0, 2]:
        # inputselect 0 corresponds to signal input 1
        out_channel = 0
        in_channel = 0
    elif scope_inputselect in [1, 3]:
        # inputselect 0 corresponds to signal input 2
        out_channel = 1
        in_channel = 1
    else:
        raise Exception(
            "This example only supports signal inputs and outputs; it does not support scope "
            f"inputselect {scope_inputselect}. Use 0, 1, 2 or 3 instead."
        )

    osc_index = 0
    demod_index = 0
    frequency = 1e6
    exp_setting = [
        ["/%s/sigins/%d/ac" % (device, in_channel), 0],
        ["/%s/sigins/%d/range" % (device, in_channel), 2 * sigouts_amplitude],
        ["/%s/sigins/%d/diff" % (device, in_channel), 0],
    ]
    daq.set(exp_setting)

    ####################################################################################################################
    # Configure the scope and obtain data with triggering disabled.
    ####################################################################################################################
    # The settings for the scope.
    #
    # The scope's sampling rate is configured by specifying the ``time`` node
    # (/devN/scopes/0/time). The rate is equal to 210e6/2**time, where 210e6 is
    # the HF2 ADC's sampling rate (whose value can be read from the device's
    # clockbase node, /devX/clockbase). ``time`` is an integer in range(0,16).
    #
    # Since the length of a scope record is fixed (2048) on an HF2, specifying the
    # rate also specifies the time duration of a scope record,
    # t_shot=2048*1./rate=2048*2**time/210e6.
    #
    # Therefore, if we would like to obtain (at least) 10 periods of the signal
    # generated by Oscillator 1, we need to set the scope's time parameter as
    # following:
    clockbase = float(daq.getInt("/%s/clockbase" % device))  # 210e6 for HF2
    desired_t_shot = 10.0 / frequency
    scope_time = np.ceil(np.max([0, np.log2(clockbase * desired_t_shot / 2048.0)]))
    if scope_time > 15:
        scope_time = 15
        warnings.warn(
            "Can't not obtain scope durations of %.3f s, scope record duration will be %.3f."
            % (desired_t_shot, 2048.0 * 2 ** scope_time / clockbase)
        )
    print("Will set /%s/scopes/0/time to %d." % (device, scope_time))

    scope_settings = [
        ["/%s/scopes/0/channel" % (device), scope_inputselect],
        ["/%s/scopes/0/trigchannel" % (device), -1],
        ["/%s/scopes/0/trigholdoff" % (device), 0.1],
        # Enable bandwidth limiting: avoid antialiasing effects due to
        # sub-sampling when the scope sample rate is less than the input
        # channel's sample rate.
        ["/%s/scopes/0/bwlimit" % (device), 1],
        # Set the sampling rate.
        ["/%s/scopes/0/time" % (device), scope_time],
        # Enable the scope
        ["/%s/scopes/0/enable" % device, 1],
    ]
    daq.set(scope_settings)

    # Perform a global synchronisation between the device and the data server:
    # Ensure that the settings have taken effect on the device before acquiring
    # data.
    daq.sync()

    # Now initialize and configure the Scope Module.
    scopeModule = daq.scopeModule(1)
    # 'mode' : Scope data processing mode.
    # 0 - Pass through scope segments assembled, returned unprocessed, non-interleaved.
    # 1 - Moving average, scope recording assembled, scaling applied, averaged, if averaging is enabled.
    # 2 - Not yet supported.
    # 3 - As for mode 1, except an FFT is applied to every segment of the scope recording.
    scopeModule.set("mode", 1)
    # 'averager/weight' : Averager behaviour.
    #   weight=1 - don't average.
    #   weight>1 - average the scope record shots using an exponentially weighted moving average.
    scopeModule.set("averager/weight", module_averaging_weight)
    # 'historylength' : The number of scope records to keep in the Scope Module's memory, when more records
    #   arrive in the Module from the device the oldest records are overwritten.
    scopeModule.set("historylength", module_historylength)

    scope_channel_lookup = {0: "sigin0", 1: "sigin1", 2: "sigout0", 3: "sigout1"}
    scope_channel = scope_channel_lookup[scope_inputselect]
    if scope_channel == "sigin0":
        externalscaling = daq.getDouble(f"/{device}/sigins/0/range")
    elif scope_channel == "sigin1":
        externalscaling = daq.getDouble(f"/{device}/sigins/1/range")
    elif scope_channel == "sigout0":
        externalscaling = daq.getDouble(f"/{device}/sigouts/0/range")
    elif scope_channel == "sigout1":
        externalscaling = daq.getDouble(f"/{device}/sigouts/1/range")
    scopeModule.set("externalscaling", externalscaling)

    # Subscribe to the scope's data in the module.
    wave_nodepath = f"/{device}/scopes/0/wave"
    scopeModule.subscribe(wave_nodepath)

    return daq, scopeModule


def get_scope_records(device, daq, scopeModule, num_records=1):
    """
    Obtain scope records from the device using an instance of the Scope Module.
    """

    # Tell the module to be ready to acquire data; reset the module's progress to 0.0.
    scopeModule.execute()

    # Enable the scope: Now the scope is ready to record data upon receiving triggers.
    daq.setInt("/%s/scopes/0/enable" % device, 1)
    daq.sync()

    start = time.time()
    timeout = 1  # [s]
    records = 0
    progress = 0
    # Wait until the Scope Module has received and processed the desired number of records.
    while (records < num_records) or (progress < 1.0):
        time.sleep(0.5)
        records = scopeModule.getInt("records")
        progress = scopeModule.progress()[0]
        print(
            f"Scope module has acquired {records} records (requested {num_records}). "
            f"Progress of current segment {100.0 * progress}%.",
            end="\r",
        )
        # Advanced use: It's possible to read-out data before all records have been recorded (or even before all
        # segments in a multi-segment record have been recorded). Note that complete records are removed from the Scope
        # Module and can not be read out again; the read-out data must be managed by the client code. If a multi-segment
        # record is read-out before all segments have been recorded, the wave data has the same size as the complete
        # data and scope data points currently unacquired segments are equal to 0.
        #
        data = scopeModule.read(False)
        
         
        if (time.time() - start) > timeout:
            # Break out of the loop if for some reason we're no longer receiving scope data from the device.
            print(f"\nScope Module did not return {num_records} records after {timeout} s - forcing stop.")
            break
    print("")
    daq.setInt("/%s/scopes/0/enable" % device, 0)

    # Read out the scope data from the module.
    #data = scopeModule.read(True)

    # Stop the module; to use it again we need to call execute().
    scopeModule.finish()

    return data

def check_scope_record_flags(scope_records):
    num_records = len(scope_records)
    for index, record in enumerate(scope_records):
        if record[0]["flags"] & 1:
            print(f"Warning: Scope record {index}/{num_records} flag indicates dataloss.")
        if record[0]["flags"] & 2:
            print(f"Warning: Scope record {index}/{num_records} indicates missed trigger.")
        if record[0]["flags"] & 4:
            print(f"Warning: Scope record {index}/{num_records} indicates transfer failure (corrupt data).")
        totalsamples = record[0]["totalsamples"]
        for wave in record[0]["wave"]:
            # Check that the wave in each scope channel contains the expected number of samples.
            assert len(wave) == totalsamples, f"Scope record {index}/{num_records} size does not match totalsamples."